node_t *build_equality_op_node2(equality_op_t op, node_t *left, node_t *right, char error_msg[ERRORMSGLENGTH]) {
    node_t *result;
    const_node_t *const_node_view_left, *const_node_view_right, *const_node_view_result;
    reference_node_t *reference_node_view_left, *reference_node_view_right;
    logical_op_node_t *logical_op_node_view_left, *logical_op_node_view_right;
    relation_op_node_t *relation_op_node_view_left, *relation_op_node_view_right;
    equality_op_node_t *equality_op_node_view_left, *equality_op_node_view_right, *equality_op_node_view_result;
    not_op_node_t *not_op_node_view_left, *not_op_node_view_right;
    integer_op_node_t *integer_op_node_view_left, *integer_op_node_view_right;
    invert_op_node_t *invert_op_node_view_left, *invert_op_node_view_right;

    qualifier_t qualifier_left, qualifier_right;
    type_t type_left, type_right;

    switch (left->type) {
        case CONST_NODE_T: {
            const_node_view_left = (const_node_t *) left;
            type_left = const_node_view_left->var_info.type;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                    type_right = const_node_view_right->var_info.type;
                    switch (type_left) {
                        case BOOL_T: {
                            if (type_right == BOOL_T) {
                                result = left;
                                const_node_view_result = (const_node_t *) result;
                                if (op == EQ_OP) {
                                    const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.bval == const_node_view_right->var_info.value.bval;
                                } else {
                                    const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.bval != const_node_view_right->var_info.value.bval;
                                }
                                free(const_node_view_right);
                                return result;
                            } else {
                                snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                         type_to_str(type_right));
                                return NULL;
                            }
                        }
                        case INT_T: {
                            switch (type_right) {
                                case BOOL_T: {
                                    snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of int and bool", (op == EQ_OP) ? "equality" : "inequality");
                                    return NULL;
                                }
                                case INT_T: {
                                    result = left;
                                    const_node_view_result = (const_node_t *) result;
                                    const_node_view_result->var_info.type = BOOL_T;
                                    if (op == EQ_OP) {
                                        const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.ival == const_node_view_right->var_info.value.ival;
                                    } else {
                                        const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.ival != const_node_view_right->var_info.value.ival;
                                    }
                                    free(const_node_view_right);
                                    return result;
                                }
                                case UNSIGNED_T: {
                                    result = left;
                                    const_node_view_result = (const_node_t *) result;
                                    const_node_view_result->var_info.type = BOOL_T;
                                    if (op == EQ_OP) {
                                        const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.ival == const_node_view_right->var_info.value.uval;
                                    } else {
                                        const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.ival != const_node_view_right->var_info.value.uval;
                                    }
                                    free(const_node_view_right);
                                    return result;
                                }
                                case VOID_T: {
                                    snprintf(error_msg, ERRORMSGLENGTH, "Right-hand side of %s is ill-formed", (op == EQ_OP) ? "equality" : "inequality");
                                    return NULL;
                                }
                            }
                        }
                        case UNSIGNED_T: {
                            switch (type_right) {
                                case BOOL_T: {
                                    snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of unsigned and bool", (op == EQ_OP) ? "equality" : "inequality");
                                    return NULL;
                                }
                                case INT_T: {
                                    result = left;
                                    const_node_view_result = (const_node_t *) result;
                                    const_node_view_result->var_info.type = BOOL_T;
                                    if (op == EQ_OP) {
                                        const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.uval == const_node_view_right->var_info.value.ival;
                                    } else {
                                        const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.uval != const_node_view_right->var_info.value.ival;
                                    }
                                    free(const_node_view_right);
                                    return result;
                                }
                                case UNSIGNED_T: {
                                    result = left;
                                    const_node_view_result = (const_node_t *) result;
                                    const_node_view_result->var_info.type = BOOL_T;
                                    if (op == EQ_OP) {
                                        const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.uval == const_node_view_right->var_info.value.uval;
                                    } else {
                                        const_node_view_result->var_info.value.bval = const_node_view_left->var_info.value.uval != const_node_view_right->var_info.value.uval;
                                    }
                                    free(const_node_view_right);
                                    return result;
                                }
                                case VOID_T: {
                                    snprintf(error_msg, ERRORMSGLENGTH, "Right-hand side of %s is ill-formed", (op == EQ_OP) ? "equality" : "inequality");
                                    return NULL;
                                }
                            }
                        }
                        case VOID_T: {
                            snprintf(error_msg, ERRORMSGLENGTH, "Left-hand side of %s is ill-formed", (op == EQ_OP) ? "equality" : "inequality");
                            return NULL;
                        }
                    }
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    qualifier_right = reference_node_view_right->var_info.qualifier;
                    type_right = reference_node_view_right->var_info.type;
                    switch (type_left) {
                        case BOOL_T: {
                            if (type_right == BOOL_T) {
                                result = new_equality_op_node(op, left, right);
                                equality_op_node_view_result = (equality_op_node_t *) result;
                                equality_op_node_view_result->var_info.qualifier = qualifier_right;
                                return result;
                            } else {
                                snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                         type_to_str(type_right));
                                return NULL;
                            }
                        }
                        case INT_T: case UNSIGNED_T: {
                            if (type_right == INT_T || type_right == UNSIGNED_T) {
                                result = new_equality_op_node(op, left, right);
                                equality_op_node_view_result = (equality_op_node_t *) result;
                                equality_op_node_view_result->var_info.qualifier = qualifier_right;
                                return result;
                            } else {
                                snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and %s", (op == EQ_OP) ? "equality" : "inequality",
                                         type_to_str(type_left), type_to_str(type_right));
                                return NULL;
                            }
                        }
                        case VOID_T: {
                            snprintf(error_msg, ERRORMSGLENGTH, "Left-hand side of %s is ill-formed", (op == EQ_OP) ? "equality" : "inequality");
                            return NULL;
                        }
                    }
                    return result;
                }
                case LOGICAL_OP_NODE_T: {
                    logical_op_node_view_right = (logical_op_node_t *) right;
                    qualifier_right = logical_op_node_view_right->var_info.qualifier;
                    if (type_left == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = qualifier_right;
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and bool", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_left));
                        return NULL;
                    }
                }
                case RELATION_OP_NODE_T: {
                    relation_op_node_view_right = (relation_op_node_t *) right;
                    qualifier_right = relation_op_node_view_right->var_info.qualifier;
                    if (type_left == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = qualifier_right;
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and bool", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_left));
                        return NULL;
                    }
                }
                case EQUALITY_OP_NODE_T: {
                    equality_op_node_view_right = (equality_op_node_t *) right;
                    qualifier_right = equality_op_node_view_right->var_info.qualifier;
                    if (type_left == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = qualifier_right;
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and bool", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_left));
                        return NULL;
                    }
                }
                case NOT_OP_NODE_T: {
                    not_op_node_view_right = (not_op_node_t *) right;
                    qualifier_right = not_op_node_view_right->var_info.qualifier;
                    if (type_left == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = qualifier_right;
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and bool", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_left));
                        return NULL;
                    }
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    qualifier_right = integer_op_node_view_right->var_info.qualifier;
                    type_right = integer_op_node_view_right->var_info.type;
                    if (type_left != BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = qualifier_right;
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_right));
                        return NULL;
                    }
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    qualifier_right = invert_op_node_view_right->var_info.qualifier;
                    type_right = invert_op_node_view_right->var_info.type;
                    if (type_left != BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = qualifier_right;
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_right));
                        return NULL;
                    }
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
                    return NULL;
                }
            }
        }
        case REFERENCE_NODE_T: {
            reference_node_view_left = (reference_node_t *) left;
            qualifier_left = reference_node_view_right->var_info.qualifier;
            type_left = reference_node_view_right->var_info.type;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                    type_right = const_node_view_right->var_info.type;
                    switch (type_left) {
                        case BOOL_T: {
                            if (type_right == BOOL_T) {
                                result = new_equality_op_node(op, left, right);
                                equality_op_node_view_result = (equality_op_node_t *) result;
                                equality_op_node_view_result->var_info.qualifier = qualifier_left;
                                return result;
                            } else {
                                snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                         type_to_str(type_right));
                                return NULL;
                            }
                        }
                        case INT_T: case UNSIGNED_T: {
                            if (type_right == INT_T || type_right == UNSIGNED_T) {
                                result = new_equality_op_node(op, left, right);
                                equality_op_node_view_result = (equality_op_node_t *) result;
                                equality_op_node_view_result->var_info.qualifier = qualifier_left;
                                return result;
                            } else {
                                snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and %s", (op == EQ_OP) ? "equality" : "inequality",
                                         type_to_str(type_left), type_to_str(type_right));
                                return NULL;
                            }
                        }
                        case VOID_T: {
                            snprintf(error_msg, ERRORMSGLENGTH, "Left-hand side of %s is ill-formed", (op == EQ_OP) ? "equality" : "inequality");
                            return NULL;
                        }
                    }
                    return result;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    qualifier_right = reference_node_view_right->var_info.qualifier;
                    type_right = reference_node_view_right->var_info.type;
                    switch (type_left) {
                        case BOOL_T: {
                            if (type_right == BOOL_T) {
                                result = new_equality_op_node(op, left, right);
                                equality_op_node_view_result = (equality_op_node_t *) result;
                                equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                                return result;
                            } else {
                                snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                         type_to_str(type_right));
                                return NULL;
                            }
                        }
                        case INT_T: case UNSIGNED_T: {
                            if (type_right == INT_T || type_right == UNSIGNED_T) {
                                result = new_equality_op_node(op, left, right);
                                equality_op_node_view_result = (equality_op_node_t *) result;
                                equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                                return result;
                            } else {
                                snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and %s", (op == EQ_OP) ? "equality" : "inequality",
                                         type_to_str(type_left), type_to_str(type_right));
                                return NULL;
                            }
                        }
                        case VOID_T: {
                            snprintf(error_msg, ERRORMSGLENGTH, "Left-hand side of %s is ill-formed", (op == EQ_OP) ? "equality" : "inequality");
                            return NULL;
                        }
                    }
                    return result;
                }
                case LOGICAL_OP_NODE_T: {
                    logical_op_node_view_right = (logical_op_node_t *) right;
                    qualifier_right = logical_op_node_view_right->var_info.qualifier;
                    if (type_left == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and bool", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_left));
                        return NULL;
                    }
                }
                case RELATION_OP_NODE_T: {
                    relation_op_node_view_right = (relation_op_node_t *) right;
                    qualifier_right = relation_op_node_view_right->var_info.qualifier;
                    if (type_left == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and bool", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_left));
                        return NULL;
                    }
                }
                case EQUALITY_OP_NODE_T: {
                    equality_op_node_view_right = (equality_op_node_t *) right;
                    qualifier_right = equality_op_node_view_right->var_info.qualifier;
                    if (type_left == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and bool", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_left));
                        return NULL;
                    }
                }
                case NOT_OP_NODE_T: {
                    not_op_node_view_right = (not_op_node_t *) right;
                    qualifier_right = not_op_node_view_right->var_info.qualifier;
                    if (type_left == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of %s and bool", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_left));
                        return NULL;
                    }
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    qualifier_right = integer_op_node_view_right->var_info.qualifier;
                    type_right = integer_op_node_view_right->var_info.type;
                    if (type_left != BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_right));
                        return NULL;
                    }
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    qualifier_right = invert_op_node_view_right->var_info.qualifier;
                    type_right = invert_op_node_view_right->var_info.type;
                    if (type_left != BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_right));
                        return NULL;
                    }
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
                    return NULL;
                }
            }
        }
        case LOGICAL_OP_NODE_T: {
            logical_op_node_view_left = (logical_op_node_t *) left;
            qualifier_left = logical_op_node_view_left->var_info.qualifier;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                    type_right = const_node_view_right->var_info.type;
                    if (type_right == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = qualifier_left;
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_right));
                        return NULL;
                    }
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    qualifier_right = reference_node_view_right->var_info.qualifier;
                    type_right = reference_node_view_right->var_info.type;
                    if (type_right == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_right));
                        return NULL;
                    }
                }
                case LOGICAL_OP_NODE_T: {
                    logical_op_node_view_right = (logical_op_node_t *) right;
                    qualifier_right = logical_op_node_view_right->var_info.qualifier;
                    result = new_equality_op_node(op, left, right);
                    equality_op_node_view_result = (equality_op_node_t *) result;
                    equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                    return result;
                }
                case RELATION_OP_NODE_T: {
                    relation_op_node_view_right = (relation_op_node_t *) right;
                    qualifier_right = relation_op_node_view_right->var_info.qualifier;
                    result = new_equality_op_node(op, left, right);
                    equality_op_node_view_result = (equality_op_node_t *) result;
                    equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                    return result;
                }
                case EQUALITY_OP_NODE_T: {
                    equality_op_node_view_right = (equality_op_node_t *) right;
                    qualifier_right = equality_op_node_view_right->var_info.qualifier;
                    result = new_equality_op_node(op, left, right);
                    equality_op_node_view_result = (equality_op_node_t *) result;
                    equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                    return result;
                }
                case NOT_OP_NODE_T: {
                    not_op_node_view_right = (not_op_node_t *) right;
                    qualifier_right = not_op_node_view_right->var_info.qualifier;
                    result = new_equality_op_node(op, left, right);
                    equality_op_node_view_result = (equality_op_node_t *) result;
                    equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    type_right = integer_op_node_view_right->var_info.type;
                    snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                             type_to_str(type_right));
                    return NULL;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    type_right = invert_op_node_view_right->var_info.type;
                    snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                             type_to_str(type_right));
                    return NULL;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
                    return NULL;
                }
            }
        }
        case RELATION_OP_NODE_T: {
            relation_op_node_view_left = (relation_op_node_t *) left;
            qualifier_left = relation_op_node_view_left->var_info.qualifier;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                    type_right = const_node_view_right->var_info.type;
                    if (type_right == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = qualifier_left;
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_right));
                        return NULL;
                    }
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    qualifier_right = reference_node_view_right->var_info.qualifier;
                    type_right = reference_node_view_right->var_info.type;
                    if (type_right == BOOL_T) {
                        result = new_equality_op_node(op, left, right);
                        equality_op_node_view_result = (equality_op_node_t *) result;
                        equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                        return result;
                    } else {
                        snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                                 type_to_str(type_right));
                        return NULL;
                    }
                }
                case LOGICAL_OP_NODE_T: {
                    logical_op_node_view_right = (logical_op_node_t *) right;
                    qualifier_right = logical_op_node_view_right->var_info.qualifier;
                    result = new_equality_op_node(op, left, right);
                    equality_op_node_view_result = (equality_op_node_t *) result;
                    equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                    return result;
                }
                case RELATION_OP_NODE_T: {
                    relation_op_node_view_right = (relation_op_node_t *) right;
                    qualifier_right = relation_op_node_view_right->var_info.qualifier;
                    result = new_equality_op_node(op, left, right);
                    equality_op_node_view_result = (equality_op_node_t *) result;
                    equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                    return result;
                }
                case EQUALITY_OP_NODE_T: {
                    equality_op_node_view_right = (equality_op_node_t *) right;
                    qualifier_right = equality_op_node_view_right->var_info.qualifier;
                    result = new_equality_op_node(op, left, right);
                    equality_op_node_view_result = (equality_op_node_t *) result;
                    equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                    return result;
                }
                case NOT_OP_NODE_T: {
                    not_op_node_view_right = (not_op_node_t *) right;
                    qualifier_right = not_op_node_view_right->var_info.qualifier;
                    result = new_equality_op_node(op, left, right);
                    equality_op_node_view_result = (equality_op_node_t *) result;
                    equality_op_node_view_result->var_info.qualifier = propagate_qualifier(qualifier_left, qualifier_right);
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    type_right = integer_op_node_view_right->var_info.type;
                    snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                             type_to_str(type_right));
                    return NULL;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    type_right = invert_op_node_view_right->var_info.type;
                    snprintf(error_msg, ERRORMSGLENGTH, "Checking %s of bool and %s", (op == EQ_OP) ? "equality" : "inequality",
                             type_to_str(type_right));
                    return NULL;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
                    return NULL;
                }
            }
        }
        case EQUALITY_OP_NODE_T: {
            equality_op_node_view_left = (equality_op_node_t *) left;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    return result;
                }
                case LOGICAL_OP_NODE_T: {
                    logical_op_node_view_right = (logical_op_node_t *) right;
                    return result;
                }
                case RELATION_OP_NODE_T: {
                    relation_op_node_view_right = (relation_op_node_t *) right;
                    return result;
                }
                case EQUALITY_OP_NODE_T: {
                    equality_op_node_view_right = (equality_op_node_t *) right;
                    return result;
                }
                case NOT_OP_NODE_T: {
                    not_op_node_view_right = (not_op_node_t *) right;
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    return result;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    return result;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
                    return NULL;
                }
            }
        }
        case NOT_OP_NODE_T: {
            not_op_node_view_left = (not_op_node_t *) left;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    return result;
                }
                case LOGICAL_OP_NODE_T: {
                    logical_op_node_view_right = (logical_op_node_t *) right;
                    return result;
                }
                case RELATION_OP_NODE_T: {
                    relation_op_node_view_right = (relation_op_node_t *) right;
                    return result;
                }
                case EQUALITY_OP_NODE_T: {
                    equality_op_node_view_right = (equality_op_node_t *) right;
                    return result;
                }
                case NOT_OP_NODE_T: {
                    not_op_node_view_right = (not_op_node_t *) right;
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    return result;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    return result;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
                    return NULL;
                }
            }
        }
        case INTEGER_OP_NODE_T: {
            integer_op_node_view_left = (integer_op_node_t *) left;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    return result;
                }
                case LOGICAL_OP_NODE_T: {
                    logical_op_node_view_right = (logical_op_node_t *) right;
                    return result;
                }
                case RELATION_OP_NODE_T: {
                    relation_op_node_view_right = (relation_op_node_t *) right;
                    return result;
                }
                case EQUALITY_OP_NODE_T: {
                    equality_op_node_view_right = (equality_op_node_t *) right;
                    return result;
                }
                case NOT_OP_NODE_T: {
                    not_op_node_view_right = (not_op_node_t *) right;
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    return result;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    return result;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
                    return NULL;
                }
            }
        }
        case INVERT_OP_NODE_T: {
            invert_op_node_view_left = (invert_op_node_t *) left;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    return result;
                }
                case LOGICAL_OP_NODE_T: {
                    logical_op_node_view_right = (logical_op_node_t *) right;
                    return result;
                }
                case RELATION_OP_NODE_T: {
                    relation_op_node_view_right = (relation_op_node_t *) right;
                    return result;
                }
                case EQUALITY_OP_NODE_T: {
                    equality_op_node_view_right = (equality_op_node_t *) right;
                    return result;
                }
                case NOT_OP_NODE_T: {
                    not_op_node_view_right = (not_op_node_t *) right;
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    return result;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    return result;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
                    return NULL;
                }
            }
        }
        default: {
            snprintf(error_msg, ERRORMSGLENGTH, "IMPLEMENT ERROR MESSAGE");
            return NULL;
        }
    }
}

node_t *build_not_op_node(node_t *child, char error_msg[ERRORMSGLENGTH]) {
    node_t *result;
    const_node_t *const_node_view_child, *const_node_view_result;
    reference_node_t *reference_node_view_child;
    logical_op_node_t *logical_op_node_view_child;
    relation_op_node_t *relation_op_node_view_child;
    equality_op_node_t *equality_op_node_view_child;
    not_op_node_t *not_op_node_view_child, *not_op_node_view_result;

    switch (child->type) {
        case CONST_NODE_T: {
            const_node_view_child = (const_node_t *) child;
            if (const_node_view_child->var_info.type == BOOL_T) {
                result = child;
                const_node_view_result = (const_node_t *) result;
                const_node_view_result->var_info.value.bval = !(const_node_view_result->var_info.value.bval);
            } else {
                snprintf(error_msg, ERRORMSGLENGTH, "Applying \"!\" to non-boolean expression");
                return NULL;
            }
            return result;
        }
        case LOGICAL_OP_NODE_T: {
            logical_op_node_view_child = (logical_op_node_t *) child;
            result = new_not_op_node(child);
            not_op_node_view_result = (not_op_node_t *) result;
            not_op_node_view_result->var_info.qualifier = logical_op_node_view_child->var_info.qualifier;
            return result;
        }
        case RELATION_OP_NODE_T: {
            relation_op_node_view_child = (relation_op_node_t *) child;
            result = new_not_op_node(child);
            not_op_node_view_result = (not_op_node_t *) result;
            not_op_node_view_result->var_info.qualifier = relation_op_node_view_child->var_info.qualifier;
            return result;
        }
        case EQUALITY_OP_NODE_T: {
            equality_op_node_view_child = (equality_op_node_t *) child;
            result = new_not_op_node(child);
            not_op_node_view_result = (not_op_node_t *) result;
            not_op_node_view_result->var_info.qualifier = equality_op_node_view_child->var_info.qualifier;
            return result;
        }
        case NOT_OP_NODE_T: {
            not_op_node_view_child = (not_op_node_t *) child;
            result = not_op_node_view_child->child;
            free(not_op_node_view_child);
            return result;
        }
        case REFERENCE_NODE_T: {
            reference_node_view_child = (reference_node_t *) child;
            if (reference_node_view_child->var_info.type == BOOL_T) {
                result = new_not_op_node(child);
                not_op_node_view_result = (not_op_node_t *) result;
                not_op_node_view_result->var_info.qualifier = reference_node_view_child->var_info.qualifier;
            } else {
                snprintf(error_msg, ERRORMSGLENGTH, "Applying \"!\" to non-boolean variable %s", reference_node_view_child->entry->name);
                return NULL;
            }
            return result;
        }
        default: {
            snprintf(error_msg, ERRORMSGLENGTH, "Applying \"!\" to non-boolean expression");
            return NULL;
        }
    }
}

node_t *build_integer_op_node2(integer_op_t op, node_t *left, node_t *right, char error_msg[ERRORMSGLENGTH]) {
    node_t *result;
    const_node_t *const_node_view_left, *const_node_view_right, *const_node_view_result;
    reference_node_t *reference_node_view_left, *reference_node_view_right;
    integer_op_node_t *integer_op_node_view_left, *integer_op_node_view_right, *integer_op_node_view_result;
    invert_op_node_t *invert_op_node_view_left, *invert_op_node_view_right;

    switch (left->type) {
        case CONST_NODE_T: {
            const_node_view_left = (const_node_t *) left;
            if (const_node_view_left->var_info.type == BOOL_T) {
                snprintf(error_msg, ERRORMSGLENGTH, "Left operand of \"%s\" is a boolean expression",
                         integer_op_to_str(op));
                return NULL;
            }
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                    if (const_node_view_right->var_info.type == BOOL_T) {
                        snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                                 integer_op_to_str(op));
                        return NULL;
                    }
                    result = left;
                    const_node_view_result = (const_node_t *) result;
                    if (const_node_view_result->var_info.type == INT_T) {
                        if (const_node_view_right->var_info.type == INT_T) {
                            switch (op) {
                                case ADD_OP: {
                                    const_node_view_result->var_info.value.ival += const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case AND_OP: {
                                    const_node_view_result->var_info.value.ival &= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case DIV_OP: {
                                    if (const_node_view_right->var_info.value.ival == 0) {
                                        snprintf(error_msg, ERRORMSGLENGTH, "Division by zero");
                                        return NULL;
                                    }
                                    const_node_view_result->var_info.value.ival /= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case MOD_OP: {
                                    if (const_node_view_right->var_info.value.ival == 0) {
                                        snprintf(error_msg, ERRORMSGLENGTH, "Modulo by zero");
                                        return NULL;
                                    }
                                    const_node_view_result->var_info.value.ival %= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case MUL_OP: {
                                    const_node_view_result->var_info.value.ival *= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case OR_OP: {
                                    const_node_view_result->var_info.value.ival |= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case SUB_OP: {
                                    const_node_view_result->var_info.value.ival -= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case XOR_OP: {
                                    const_node_view_result->var_info.value.ival ^= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                            }
                        } else {
                            switch (op) {
                                case ADD_OP: {
                                    const_node_view_result->var_info.value.uval = const_node_view_left->var_info.value.ival + const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case AND_OP: {
                                    const_node_view_result->var_info.value.uval = const_node_view_left->var_info.value.ival & const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case DIV_OP: {
                                    if (const_node_view_right->var_info.value.uval == 0) {
                                        snprintf(error_msg, ERRORMSGLENGTH, "Division by zero");
                                        return NULL;
                                    }
                                    const_node_view_result->var_info.value.uval = const_node_view_left->var_info.value.ival / const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case MOD_OP: {
                                    if (const_node_view_right->var_info.value.uval == 0) {
                                        snprintf(error_msg, ERRORMSGLENGTH, "Modulo by zero");
                                        return NULL;
                                    }
                                    const_node_view_result->var_info.value.uval = const_node_view_left->var_info.value.ival % const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case MUL_OP: {
                                    const_node_view_result->var_info.value.uval = const_node_view_left->var_info.value.ival * const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case OR_OP: {
                                    const_node_view_result->var_info.value.uval = const_node_view_left->var_info.value.ival | const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case SUB_OP: {
                                    const_node_view_result->var_info.value.uval = const_node_view_left->var_info.value.ival - const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case XOR_OP: {
                                    const_node_view_result->var_info.value.uval = const_node_view_left->var_info.value.ival ^ const_node_view_right->var_info.value.uval;
                                    break;
                                }
                            }
                        }
                    } else {
                        if (const_node_view_right->var_info.type == INT_T) {
                            const_node_view_result->var_info.type = UNSIGNED_T;
                            switch (op) {
                                case ADD_OP: {
                                    const_node_view_result->var_info.value.uval += const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case AND_OP: {
                                    const_node_view_result->var_info.value.uval &= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case DIV_OP: {
                                    if (const_node_view_right->var_info.value.ival == 0) {
                                        snprintf(error_msg, ERRORMSGLENGTH, "Division by zero");
                                        return NULL;
                                    }
                                    const_node_view_result->var_info.value.uval /= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case MOD_OP: {
                                    if (const_node_view_right->var_info.value.ival == 0) {
                                        snprintf(error_msg, ERRORMSGLENGTH, "Modulo by zero");
                                        return NULL;
                                    }
                                    const_node_view_result->var_info.value.uval %= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case MUL_OP: {
                                    const_node_view_result->var_info.value.uval *= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case OR_OP: {
                                    const_node_view_result->var_info.value.uval |= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case SUB_OP: {
                                    const_node_view_result->var_info.value.uval -= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                                case XOR_OP: {
                                    const_node_view_result->var_info.value.uval ^= const_node_view_right->var_info.value.ival;
                                    break;
                                }
                            }
                        } else {
                            switch (op) {
                                case ADD_OP: {
                                    const_node_view_result->var_info.value.uval += const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case AND_OP: {
                                    const_node_view_result->var_info.value.uval &= const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case DIV_OP: {
                                    if (const_node_view_right->var_info.value.uval == 0) {
                                        snprintf(error_msg, ERRORMSGLENGTH, "Division by zero");
                                        return NULL;
                                    }
                                    const_node_view_result->var_info.value.uval /= const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case MOD_OP: {
                                    if (const_node_view_right->var_info.value.uval == 0) {
                                        snprintf(error_msg, ERRORMSGLENGTH, "Modulo by zero");
                                        return NULL;
                                    }
                                    const_node_view_result->var_info.value.uval %= const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case MUL_OP: {
                                    const_node_view_result->var_info.value.uval *= const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case OR_OP: {
                                    const_node_view_result->var_info.value.uval |= const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case SUB_OP: {
                                    const_node_view_result->var_info.value.uval -= const_node_view_right->var_info.value.uval;
                                    break;
                                }
                                case XOR_OP: {
                                    const_node_view_result->var_info.value.uval ^= const_node_view_right->var_info.value.uval;
                                    break;
                                }
                            }
                        }
                    }
                    free(const_node_view_right);
                    return result;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    if (reference_node_view_right->var_info.type == BOOL_T) {
                        snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                                 integer_op_to_str(op));
                        return NULL;
                    }
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    integer_op_node_view_result->var_info.qualifier = reference_node_view_right->var_info.qualifier;
                    if (const_node_view_left->var_info.type == reference_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = const_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    integer_op_node_view_result->var_info.qualifier = integer_op_node_view_right->var_info.qualifier;
                    if (const_node_view_left->var_info.type == integer_op_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = const_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    integer_op_node_view_result->var_info.qualifier = invert_op_node_view_right->var_info.qualifier;
                    if (const_node_view_left->var_info.type == invert_op_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = const_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                             integer_op_to_str(op));
                    return NULL;
                }
            }
        }
        case REFERENCE_NODE_T: {
            reference_node_view_left = (reference_node_t *) left;
            if (reference_node_view_left->var_info.type == BOOL_T) {
                snprintf(error_msg, ERRORMSGLENGTH, "Left operand of \"%s\" is a boolean expression",
                         integer_op_to_str(op));
                return NULL;
            }
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                    if (const_node_view_right->var_info.type == BOOL_T) {
                        snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                                 integer_op_to_str(op));
                        return NULL;
                    } else if (const_node_view_right->var_info.value.ival == 0) {
                        if (op == DIV_OP) {
                            snprintf(error_msg, ERRORMSGLENGTH, "Division by zero");
                            return NULL;
                        } else if (op == MOD_OP) {
                            snprintf(error_msg, ERRORMSGLENGTH, "Modulo by zero");
                            return NULL;
                        }
                    }
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    integer_op_node_view_result->var_info.qualifier = reference_node_view_left->var_info.qualifier;
                    if (reference_node_view_left->var_info.type == const_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = reference_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    if (reference_node_view_right->var_info.type == BOOL_T) {
                        snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                                 integer_op_to_str(op));
                        return NULL;
                    }
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (reference_node_view_left->var_info.qualifier == QUANTUM_T || reference_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (reference_node_view_left->var_info.type == reference_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = reference_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (reference_node_view_left->var_info.qualifier == QUANTUM_T || integer_op_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (reference_node_view_left->var_info.type == integer_op_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = reference_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (reference_node_view_left->var_info.qualifier == QUANTUM_T || invert_op_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (reference_node_view_left->var_info.type == invert_op_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = reference_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                             integer_op_to_str(op));
                    return NULL;
                }
            }
        }
        case INTEGER_OP_NODE_T: {
            integer_op_node_view_left = (integer_op_node_t *) left;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                    if (const_node_view_right->var_info.type == BOOL_T) {
                        snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                                 integer_op_to_str(op));
                        return NULL;
                    } else if (const_node_view_right->var_info.value.ival == 0) {
                        if (op == DIV_OP) {
                            snprintf(error_msg, ERRORMSGLENGTH, "Division by zero");
                            return NULL;
                        } else if (op == MOD_OP) {
                            snprintf(error_msg, ERRORMSGLENGTH, "Modulo by zero");
                            return NULL;
                        }
                    }
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    integer_op_node_view_result->var_info.qualifier = integer_op_node_view_left->var_info.qualifier;
                    if (integer_op_node_view_left->var_info.type == const_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = integer_op_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    if (reference_node_view_right->var_info.type == BOOL_T) {
                        snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                                 integer_op_to_str(op));
                        return NULL;
                    }
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (integer_op_node_view_left->var_info.qualifier == QUANTUM_T || reference_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (integer_op_node_view_left->var_info.type == reference_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = integer_op_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (integer_op_node_view_left->var_info.qualifier == QUANTUM_T || integer_op_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (integer_op_node_view_left->var_info.type == integer_op_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = integer_op_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (integer_op_node_view_left->var_info.qualifier == QUANTUM_T || invert_op_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (integer_op_node_view_left->var_info.type == invert_op_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = integer_op_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                             integer_op_to_str(op));
                    return NULL;
                }
            }
        }
        case INVERT_OP_NODE_T: {
            invert_op_node_view_left = (invert_op_node_t *) left;
            switch (right->type) {
                case CONST_NODE_T: {
                    const_node_view_right = (const_node_t *) right;
                    if (const_node_view_right->var_info.type == BOOL_T) {
                        snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                                 integer_op_to_str(op));
                        return NULL;
                    } else if (const_node_view_right->var_info.value.ival == 0) {
                        if (op == DIV_OP) {
                            snprintf(error_msg, ERRORMSGLENGTH, "Division by zero");
                            return NULL;
                        } else if (op == MOD_OP) {
                            snprintf(error_msg, ERRORMSGLENGTH, "Modulo by zero");
                            return NULL;
                        }
                    }
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    integer_op_node_view_result->var_info.qualifier = invert_op_node_view_left->var_info.qualifier;
                    if (invert_op_node_view_left->var_info.type == const_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = invert_op_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case REFERENCE_NODE_T: {
                    reference_node_view_right = (reference_node_t *) right;
                    if (reference_node_view_right->var_info.type == BOOL_T) {
                        snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                                 integer_op_to_str(op));
                        return NULL;
                    }
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (invert_op_node_view_left->var_info.qualifier == QUANTUM_T || reference_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (invert_op_node_view_left->var_info.type == reference_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = invert_op_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case INTEGER_OP_NODE_T: {
                    integer_op_node_view_right = (integer_op_node_t *) right;
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (invert_op_node_view_left->var_info.qualifier == QUANTUM_T || integer_op_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (invert_op_node_view_left->var_info.type == integer_op_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = invert_op_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                case INVERT_OP_NODE_T: {
                    invert_op_node_view_right = (invert_op_node_t *) right;
                    result = new_integer_op_node(op, left, right);
                    integer_op_node_view_result = (integer_op_node_t *) result;
                    if (invert_op_node_view_left->var_info.qualifier == QUANTUM_T || invert_op_node_view_right->var_info.qualifier == QUANTUM_T) {
                        integer_op_node_view_result->var_info.qualifier = QUANTUM_T;
                    } else {
                        integer_op_node_view_result->var_info.qualifier = NONE_T;
                    }
                    if (invert_op_node_view_left->var_info.type == invert_op_node_view_right->var_info.type) {
                        integer_op_node_view_result->var_info.type = invert_op_node_view_left->var_info.type;
                    } else {
                        integer_op_node_view_result->var_info.type = UNSIGNED_T;
                    }
                    return result;
                }
                default: {
                    snprintf(error_msg, ERRORMSGLENGTH, "Right operand of \"%s\" is a boolean expression",
                             integer_op_to_str(op));
                    return NULL;
                }
            }
        }
        default: {
            snprintf(error_msg, ERRORMSGLENGTH, "Left operand of \"%s\" is a boolean expression",
                     integer_op_to_str(op));
            return NULL;
        }
    }
}

node_t *build_invert_op_node(node_t *child, char error_msg[ERRORMSGLENGTH]) {
    node_t *result;
    const_node_t *const_node_view_child, *const_node_view_result;
    reference_node_t *reference_node_view_child;
    integer_op_node_t *integer_op_node_view_child;
    invert_op_node_t *invert_op_node_view_child, *invert_op_node_view_result;

    switch (child->type) {
        case CONST_NODE_T: {
            const_node_view_child = (const_node_t *) child;
            if (const_node_view_child->var_info.type == INT_T) {
                result = child;
                const_node_view_result = (const_node_t *) result;
                const_node_view_result->var_info.value.ival = ~(const_node_view_result->var_info.value.ival);
            } else if (const_node_view_child->var_info.type == UNSIGNED_T) {
                result = child;
                const_node_view_result = (const_node_t *) result;
                const_node_view_result->var_info.value.uval = ~(const_node_view_result->var_info.value.uval);
            } else {
                snprintf(error_msg, ERRORMSGLENGTH, "Applying \"~\" to a boolean expression");
                return NULL;
            }
            return result;
        }
        case REFERENCE_NODE_T: {
            reference_node_view_child = (reference_node_t *) child;
            if (reference_node_view_child->var_info.type == INT_T || reference_node_view_child->var_info.type == UNSIGNED_T) {
                result = new_invert_op_node(child);
                invert_op_node_view_result = (invert_op_node_t *) result;
                invert_op_node_view_result->var_info.qualifier = reference_node_view_child->var_info.qualifier;
                invert_op_node_view_result->var_info.type = reference_node_view_child->var_info.type;
            } else {
                snprintf(error_msg, ERRORMSGLENGTH, "Applying \"~\" to boolean variable %s", reference_node_view_child->entry->name);
                return NULL;
            }
            return result;
        }
        case INTEGER_OP_NODE_T: {
            integer_op_node_view_child = (integer_op_node_t *) child;
            result = new_invert_op_node(child);
            invert_op_node_view_result = (invert_op_node_t *) result;
            invert_op_node_view_result->var_info.qualifier = integer_op_node_view_child->var_info.qualifier;
            invert_op_node_view_result->var_info.type = integer_op_node_view_child->var_info.type;
            return result;
        }
        case INVERT_OP_NODE_T: {
            invert_op_node_view_child = (invert_op_node_t *) child;
            result = invert_op_node_view_child->child;
            free(invert_op_node_view_child);
            return result;
        }
        default: {
            snprintf(error_msg, ERRORMSGLENGTH, "Applying \"~\" to boolean expression");
            return NULL;
        }
    }
}
